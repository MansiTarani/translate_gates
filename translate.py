# -*- coding: utf-8 -*-
"""translate.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/106QI5Z-WLPFQL901Jwwl-yH1GREOQtbm

Task 3
Question

Please write a simple compiler – program, which translates one quantum circuit into another, using a restricted set of gates.

You need to consider just the basic gates for the input circuit, such as (I, H, X, Y, Z, RX, RY, RZ, CNOT, CZ).

The output circuit should consist only from the following gates: RX, RZ, CZ. In other words, each gate in the original circuit must be replaced by an equivalent combination of gates coming from the restricted set (RX, RZ, CZ) only.

For example, a Hadamard gate after compilation looks like this:

RZ(pi/2)
RX(pi/2)
RZ(pi/2)

Analyze what’s the overhead of the compiled program compared to the original one and propose how to improve it. What we mean by overhead is the following: by replacing all the initial gates with the restricted set of gates given in the problem, you will see that the resulting circuit is much more involved than the original one. This is what we called the overhead, and you may think about how to treat this problem, i.e. you could try to simplify as much as possible the resulting circuit.
"""

# Commented out IPython magic to ensure Python compatibility.
!pip install qiskit
!pip install array_to_latex
import matplotlib.pyplot as plt
# %matplotlib inline
import numpy as np
import math
import array_to_latex as atl

# importing Qiskit
from qiskit import IBMQ, BasicAer, Aer
from qiskit.providers.ibmq import least_busy
from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister, execute
from qiskit.quantum_info.operators import Operator
from qiskit.quantum_info import Statevector

# import basic plot tools
from qiskit.tools.visualization import plot_histogram
from qiskit.visualization import plot_bloch_multivector

backend = Aer.get_backend('statevector_simulator')

#FOR HADAMARD GATE
def hg(qubit1):
    circuit.rz(np.pi/2,qubit1)
    circuit.rx(np.pi/2,qubit1)
    circuit.rz(np.pi/2,qubit1)


    # ADDING GLOBAL PHASE
    circuit.global_phase=np.pi/2

#FOR I GATE
def ig(qubit1):
    #qi=QuantumCircuit(1)
    circuit.rz(0,qubit1)
    circuit.rx(0,qubit1)
    circuit.rz(0,qubit1)

#FOR X GATE
def xg(qubit1): 
    circuit.rx(np.pi,qubit1)


    # ADDING GLOBAL PHASE
    circuit.global_phase=np.pi/2

#FOR Y GATE
def yg(qubit1):
    #circuit=QuantumCircuit(2) 
    circuit.rz(0,qubit1)
    circuit.rx(np.pi,qubit1)
    circuit.rz(0,qubit1)
    circuit.cz(0,1)


     # ADDING GLOBAL PHASE
    circuit.global_phase=np.pi

# FOR Z GATE
def zg(qubit1):
    #circuit=QuantumCircuit(1) 
    circuit.rz(np.pi,qubit1)


    # ADDING GLOBAL PHASE
    circuit.global_phase=np.pi/2

#FOR RX GATE
def rxg(qubit1,theta=0):
    circuit.rx(theta,qubit1)

#FOR Ry GATE
def ryg(qubit1,theta=0): 
    circuit.rz(3*np.pi/2,qubit1)
    circuit.rx(theta,qubit1)
    circuit.rz(np.pi/2,qubit1)
    #circuit.cz(0,1)


      # ADDING GLOBAL PHASE
    circuit.global_phase=np.pi

#FOR RZ GATE
def rzg(qubit1,theta=0): 
    circuit.rz(theta,qubit1)

#FOR CX GATE
def cxg(qubit1,qubit2): 
    circuit.rz(np.pi/2,qubit1)
    circuit.rx(np.pi/2,qubit1)
    circuit.rz(np.pi/2,qubit1)
    circuit.cz(qubit1,qubit2)
    circuit.rz(np.pi/2,qubit1)
    circuit.rx(np.pi/2,qubit1)
    circuit.rz(np.pi/2,qubit1)
    

    #APPLYING GLOBAL PHASE
    circuit.global_phase=np.pi

#FOR CZ GATE
def czg(qubit1,qubit2): 
    circuit.cz(qubit1,qubit2)

def decompose(gate, qubit1=0, qubit2=1, theta=0):
    if (gate=='h'):
      hg(qubit1)

    elif (gate=='x'):
      xg(qubit1) 

    elif (gate=='y'):
      yg(qubit1)

    elif (gate=='z'):
      zg(qubit1)

    elif (gate=='i'):
      ig(qubit1)

    elif (gate=='rx'):
      rxg(qubit1,theta)

    elif (gate=='ry'):
      ryg(qubit1,theta)

    elif (gate=='rz'):
      rzg(qubit1,theta)

    elif (gate=='cx'):
      cxg(qubit1,qubit2)   

    elif (gate=='cz'):
      czg(qubit1,qubit2)

"""Now we will show the correctness of our code by taking the example of hardamard gate and translate it in terms of restricted set of gates"""

#all gates we want to apply
circ=QuantumCircuit(2)                           #here circ is the original circuit in which required gates are applied
circuit=QuantumCircuit(2)                        #circuit is taken for our code
circ.h(0)
print("old circuit and its statevextor")
atl.to_ltx(Statevector.from_instruction(circ).data)
circ.draw()

#on decomposing
decompose('h',0)
print("translated circuit and its statevector")
circ=circuit
atl.to_ltx(Statevector.from_instruction(circ).data)
circ.draw()

"""Now we will apply gates XYZ to circuit"""

#all gates we want to apply
circ=QuantumCircuit(2)                           #here circ is the original circuit in which required gates are applied
circuit=QuantumCircuit(2)                        #circuit is taken for our code
circ.x(0)
circ.y(0)
circ.z(0)
print("old circuit and its statevextor")
atl.to_ltx(Statevector.from_instruction(circ).data)
circ.draw()

#on decomposing
decompose('x',0)
decompose('y',0)
decompose('z',0)
print("translated circuit and its statevector")
circ=circuit
circ.global_phase=np.pi                                         #global phase of pi is needed
atl.to_ltx(Statevector.from_instruction(circ).data)
circ.draw()

"""As we can see there are 3 gates in original circuit and 5 in translated circuit.So there is a overhead of 2.
It can be simplified if we use RX(pi),RZ(0),RX(pi)
IT IS SHOWN BELOW
we can also reduce overhead by using identities to simplify the circuit
"""

#all gates we want to apply
circ=QuantumCircuit(2)                           #here circ is the original circuit in which required gates are applied                        #circuit is taken for our code
circ.rx(np.pi,0)
circ.rz(0,0)
circ.rx(np.pi,0)
circ.rz(np.pi,0)
circ.global_phase=np.pi 
print("old circuit and its statevextor")
atl.to_ltx(Statevector.from_instruction(circ).data)
circ.draw()

